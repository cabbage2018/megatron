怎么样对状态字进行bit位解码

# 问题描述 #
工业设备往往需要及时知道它的运行状态，于是就有类似“遥信” 这样专门抓取设备运行状态的行为。 如果我们自己写一款软件解析它们，该怎么做呢？ 其实很简单，阅读manual，然后根据定义去找特定offset和bit length 的digit，可能的话（例如该对象为枚举enums） 再转换成CHAR, INT, LONG - 在这么简单的一句话描述中已经有非常多的问题需要工程方案了，例如，在传统空气断路器这样大型设备这里的CHAR 是8位长，INT 是16 位长， LONG 是32位，是不是颠覆你的认知； 再有，这些数据在计算机内存的存储字节序往往是big endian 就是高级位先存储这点跟计算机本地存储的方式不一样， 如果把一个数据写成字节流就像[0x12, 0xab, 0x78, 0xef] 这是32 bit 的数据在程序里的表示，换算成整数 = 0x12ab78ef = 313227503， 这是通常的认知，也即是右边低位先到（LE）， 如果右边先到变成高位（BE） 同样一串字节流解读成 0xef78ab12 = 4017662738 这两种解读都有效但是结果大相径庭并且完全一定要看手册来决定。这样，一个好的状态字处理软件必须加入这些属性，就是字节序属性作为输入，让应用者可以选择。 题外话，一个有用的企业级软件核心就是一堆语义解码，例如AT 指令，例如 芯片 指令，例如网络设备指令/数据。 这些行业设备往往基于嵌入式软件构造为了压缩数据不可能在芯片层级使用json 或者xml 之类的东东，bit 位语义主导了大部分场景， 通信规范例如3GPP 文本里给出的也都是基于ASN.1 语法的描述。所以说掌握了解码的核心技术就使得我们日常工作游刃有余而不至于看了无数书本也看不懂一个RRC reestablished 是从哪条指令怎么截获的。

# 设计 #
首先我要规范一个表格用于描述这些场合和可能性，状态字最基本的是从一堆字节流或者叫寄存器的布局里识别出来的，例如，以3WL 这款设备来说，03/2020手册 112页 给出了主要全景数据的布局，13057 这个标号的寄存器（注意不是地址，文档中有提到）标识了Format 15 数据的起始，它总共有480 bit长度！ 另外一个重要的数据结构是Format (402) 闸刀单元告警 194页说明该数据的byte 0 的bit 1 位置表示'Overload neutral conductor' 也就是'零线过载'。 OK 实际上我们设计的解码程序考察适用范围会更有的放矢，这篇文档的状态字的长度没有横跨byte 的，就是bit length 没有超过8；但为了通用，我把这个范围设置到32 bit 也就是Node.js 能够进行位操作的数据大小（位操作31 bit 范围，32bit 我们可以用readUInt32BE 类似的函数进行处理的）。于是，了解到程序需要处理的输入属性包括
bit 偏移/
bit 数量/
这个函数有了数据流，有了这两个参数就可以工作了。
进一步的研究还表明，有时候给出数值结果还不够，例如刚才说的告警位，我们还要根据数值解析枚举量 - 告诉使用者这里的告警有没有出现，因为对于类似的bit 位如果没有变为1 也就是被置位使用者是不需要关心的。 这样就又增加了一层建模任务，即根据数值结果查表，触发事件- 这个小流程是现代工业通信中最重要的事件驱动机制的引擎。 没有这样的采数和分析能力事件的实时性就很差，根本不能够担当现场软件或者SCADA 以及DCS 软件的效能。 而如果具备了现场状态字解析和事件生成机制，则任何工业系统和近实时应用都能上。

 # 实现 #

 # 调整 #


 # 测试 #
刚开始接触这个领域很多概念还是混淆的，例如BE/LE 的本质，左移和右移的选择 ， 跨字节和字节内操作， 做完了这个项目，可以说现在来实现跨32 位字的解码理论上也可以，就是没有任何商业价值。为了理清这些混淆的概念，最简单的方法就是写单元测试。远与近都是写，怎么写还是很有学问的，以下这段测试厘清了我一直搞不清爽的大小端字节序的问题：

```
'use strict'
const expect = require('chai').expect;

describe('Array', function () {
  describe('.endian()', function () {
    it('should recover big endian ', function () {
      const buf = Buffer.from([0x12, 0xab, 0x78, 0xef]);
      let val = 0;
      for(let j = 0; j < buf.length; j ++) {
        val += parseInt(buf[j]) * Math.pow(2, 8*(j));
      }

      expect(buf.readUInt32LE(0)).to.equal(val);
    })

    it('should recover little endian', function () {
      const buf = Buffer.from([0x12, 0xab, 0x78, 0xef]);
      let val = 0;
      for(let j = 0; j < buf.length; j ++) {
        val += parseInt(buf[j]) * Math.pow(2, 8*(buf.length -1 - j));
      }

      expect(buf.readUInt32BE(0)).to.equal(val);
    })
  })
})
```
这段测试实际上用Math.pow() 模拟了系统提供的函数.readUInt32LE(0) 和 .readUInt32BE(0))；

再进一步，利用现场设备的寄存器数据做测试。例如 市电电压 总不会偏离220 太远； 市电频率不会偏离50 太远； 这两者都可以用来做数值验证。
更进一步，对于Double 类型的能耗电度数据也可以从数值解析的角度验证。它们不可能为负值，也不能随着时间减小。即使做模拟数据，我们也必须满足这种约束，这就是所谓的语义在理。


 # 小结 #
 利用解析的方法，我可以把电力测量的几个方法聚合起来，遥信、遥调、遥测都是数据的展示和分析，遥控属于控制功能安全起见不通过非局域网程序管理；原先的程序遥测的几十个数据点位占用了大量的资源，现在回过头来看，遥测只不过是位置对的很齐的FLOAT, DOUBLE, INT, LONG 的工作，只是这里的INT LONG 违反我们的常识只有市面上的一半长度而已。为什么必须区分这几类数据？ 后续处理不一样。 遥信是事件的来源之一，例如电流过载、跳闸等状态bit 的实时改变激发这个特定事件。顺便说一下，遥测数据超标也是事件来源之一 - 但是这个工作不一定要在Edge 本地处理可以拿到云上数据存储和展示阶段搞。所以后者的越限告警的紧急重要性远远不是事件级别的。

 再推广一下，OPCUA 协议可不可以用同样的格式来处理呢？

 再问问自己，还有什么其它方法来做这件事吗？从纯粹学术的角度来说，除了32 位以下这种用INT 中转的方法来解bit 域，还有什么其它方法呢？ 答案是有的，可以将字节流 byte Array 变换成二进制字符串buf.toString(2) , 补齐到特定的长度（考虑到例如全零的字节变换后只有一个'0'）, 再从右往左数位数和个数，这种直观的方法利用了字符数组，这个途径效率不是最高但是足够容易理解，也算不是一无是处。而且超级容易扩展，字符数组的长度是可扩展缩放的。这当中逻辑运算变成了字符串比较了。